#+PROPERTY: header-args    :results silent

* Package Management
** Configure package sources
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("elpa"  . "https://elpa.gnu.org/packages/")))
#+END_SRC

** Initalize pacakge system
#+BEGIN_SRC emacs-lisp
  (package-initialize) 
  (unless package-archive-contents
          (package-refresh-contents))
#+END_SRC

** Install package managing the packages
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
          (package-install     'use-package))

  (require 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC

** Configure auto-update of packages

#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :custom
    (auto-package-update-interval             7)
    (auto-package-update-prompt-before-update t)
    (auto-package-update-hide-results         t)
    :config
    (auto-package-update-maybe))
#+END_SRC

** libraries
*** list operations

The *[[https://github.com/magnars/dash.el][dash]]* library simplifies working with lists (e.g. =--map= or =--filter= functions)

#+BEGIN_SRC emacs-lisp
  (use-package dash)
#+END_SRC

*** string operations

The *[[https://github.com/magnars/s.el][s]]* library simplifies working with strings (e.g. =s-trim= or =s-pad-left= functions)

#+BEGIN_SRC emacs-lisp
  (use-package s)
#+END_SRC

*** file operations

The *[[https://github.com/rejeep/f.el][f]]* library simplifies working with files (e.g. =f-read-text= or =f-ext=)

#+BEGIN_SRC emacs-lisp
  (use-package f)
#+END_SRC

* UI
*** Theme
**** Install and load themes

#+BEGIN_SRC emacs-lisp
(use-package modus-themes
  :init
  (setq modus-themes-org-blocks        'gray-background
        modus-themes-bold-constructs   t
        modus-themes-italic-constructs t
        modus-themes-fringes           'subtle
        modus-themes-hl-line           '(intense)
        modus-themes-paren-match       '(bold intense)
        modus-themes-mode-line         '(accented)
        modus-themes-syntax            '(faint green-strings alt-syntax)
        modus-themes-region            '(accented)
        modus-themes-subtle-line-numbers nil
        modus-themes-mixed-fonts         nil
        modus-themes-prompts  '(intense background) ;; minibuffer prompts
        modus-themes-markup   '(intense background) ;; e.g. =verbatim= or ~code~
        modus-themes-links    '(faint italic background))
  (setq modus-themes-headings
        '((1 . (background overline  1.3 variable-pitch))
          (2 . (background overline  1.2 variable-pitch))
          (3 . (background overline  1.15))
          (4 . (background overline  1.1))
          (t . (monochrome))))
  (setq modus-themes-completions
        '((matches   . (extrabold background))
          (selection . (semibold accented))
          (popup     . (accented))))
  :bind ("<f5>" . modus-themes-toggle))

(load-theme 'modus-vivendi)
#+END_SRC

**** Old themes
- leuven
- zenburn

**** Other themes to consider
- doom-themes
  - doom-one-light
  - doom-palenight
  - doom-1337
  - doom-Iosvkem
  - doom-monlight
- melancholy-theme
- ample-theme
- zenburn

*** Frames

**** Disable various bars  
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode   -1)
  (menu-bar-mode   -1)
  (scroll-bar-mode -1)
  (tooltip-mode    -1)
#+END_SRC


*** Windows

**** Enable window padding on left and right
Sadly, this doesn't seem to work in terminal
#+BEGIN_SRC emacs-lisp
  (set-fringe-mode 16)
#+END_SRC

**** Respect dislay rules when manually switching buffer
#+begin_src emacs-lisp
(setq switch-to-buffer-obey-display-actions t)
#+end_src

*** Buffers

**** Make scratch-buffer empty initially
#+begin_src emacs-lisp
(setq initial-scratch-message "")
#+end_src

**** Highlight current line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)

(defun init/disable-line-highlight (mode)
  (add-hook mode (lambda () (setq-local global-hl-line-mode nil))))
#+END_SRC

**** Auto-reload externally modified buffers

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC


**** Configure tabulations

#+BEGIN_SRC emacs-lisp
  (setq tab-width 2)
#+END_SRC


**** Global Fonts

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :font "Hack" :height 210)
#+END_SRC


**** Disable startup messages

Let's have the clean buffers

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
  (setq inhibit-startup-message t)
#+END_SRC

*** Mode line

**** Show column of the point

#+BEGIN_SRC emacs-lisp
  (column-number-mode)
#+END_SRC


**** Hide minor mode on mode line

#+BEGIN_SRC emacs-lisp
  (use-package diminish)
#+END_SRC

** Keymap
#+begin_src emacs-lisp
(global-set-key (kbd "C-<tab>") #'consult-buffer)

(defun pop-to-shell (name)
  (interactive (list (completing-read
		      "Terminal: "
		      (-map (lambda (it) (buffer-name it))
			    (-filter (lambda (it) (with-current-buffer it
						    (derived-mode-p 'eshell-mode 'vterm-mode)))
				     (buffer-list))
			    ))))
  (let ((buffer (or (get-buffer name)
		    (with-current-buffer (generate-new-buffer name)
		      (eshell-mode)
		      (current-buffer)))))
    (pop-to-buffer buffer)))

(global-set-key (kbd "C-!")  #'pop-to-shell)
;; disable suspending frames
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-<wheel-down>"))
(global-unset-key (kbd "C-<wheel-up>"))
#+end_src
* Version Control
** Disable built-in version control module

#+BEGIN_SRC emacs-lisp
  (require 'vc)
  (eval-after-load "vc" '(remove-hook 'find-file-hook 'vc-find-file-hook))
  (eval-after-load "vc" '(remove-hook 'find-file-hook 'vc-refresh-state))
#+END_SRC

** Enable magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind
  ([remap magit-diff-visit-file] . magit-diff-visit-file-other-window)
  :config
  (use-package git-gutter-fringe) ;; TODO icons are quite small
  (git-gutter-mode))
#+END_SRC

* System integration
** Volume management
#+begin_src emacs-lisp
(use-package volume
  :defer 3
  :bind
  ("<XF86AudioRaiseVolume>"   . (lambda () (interactive) (volume-raise 5)))
  ("<XF86AudioLowerVolume>"   . (lambda () (interactive) (volume-lower 5)))
  ("S-<XF86AudioRaiseVolume>" . (lambda () (interactive) (volume-raise 10)))
  ("S-<XF86AudioLowerVolume>" . (lambda () (interactive) (volume-lower 10)))
  ("C-<XF86AudioLowerVolume>" . volume-minimize))
#+end_src
** Bluetooth
#+begin_src emacs-lisp
(use-package bluetooth)
#+end_src
** Docker
#+begin_src emacs-lisp
(use-package docker
  :bind ("C-c d" . docker))

(use-package dockerfile-mode)
#+end_src

#+begin_src emacs-lisp
;; from https://www.emacswiki.org/emacs/TrampAndDocker
(defvar tramp-docker-parameters
  '((tramp-login-program "docker")
    (tramp-login-args (("exec" "-it") ("%h") ("/bin/bash")))
    (tramp-remote-shell "/bin/sh")
    (tramp-remote-shell-args ("-i") ("-c"))))

(use-package tramp
  :config
  (print ">tramp")
  (push (cons "docker" tramp-docker-parameters) tramp-methods))

(defun tramp-docker-containers ()
  (let* ((command "docker ps | awk '$NF != \"NAMES\" { print $NF \":\" }'")
	 (raw-output (shell-command-to-string command))
	 (lines (split-string raw-output "\n")))
    (cl-remove-if-not #'(lambda (it) (string-match ":$" it)) lines)))

(defadvice tramp-completion-handle-file-name-all-completions
    (around dotemacs-completion-docker activate)
  "(tramp-completion-handle-file-name-all-completions \"\" \"/docker:\" returns
    a list of active Docker container names, followed by colons."
  (if (equal (ad-get-arg 1) "/docker:")
        (setq ad-return-value (tramp-docker-containers))
    ad-do-it))
#+end_src
** Books
#+begin_src emacs-lisp
(use-package calibredb
  :config
  (setq calibredb-root-dir "~/Documents/Books"
	calibredb-library-alist '(("~/Documents/Books"))
	calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir)))
#+end_src
** Automatic PATH adjustment
*** Include all binaries from =~/opt/*/bin=
#+begin_src emacs-lisp
(--> (f-directories "~/opt")
     (-map (lambda (it) (f-join it "bin")) it)
     (-filter #'f-dir? it)
     (-concat it exec-path)
     (-uniq it)
     (setq exec-path it))
#+end_src

* User experience
** Completion

*** Popup completions
#+BEGIN_SRC emacs-lisp
(setq tab-always-indent 'complete) ;; indent if needed, then complete

(use-package corfu
  :config
  (setq corfu-auto            nil)
  (setq corfu-cycle           t)
  (setq corfu-separator       ?\s)
  (setq corfu-preselect-first t)
  (setq corfu-popupinfo-delay '(0.3 . t))
  :bind
  (:map corfu-map
	("SPC" . corfu-insert-separator)
	("<tab>" . corfu-next)
	("<backtab>" . corfu-previous))
  :init
  (global-corfu-mode)
  ;; (corfu-popupinfo-mode) currently fails with: corfu-post-command wrong-type number-or-marker t
  )

(defun corfu-enable-in-minibuffer ()
  "Enable Corfu in the minibuffer if `completion-at-point' is bound."
  (when (where-is-internal #'completion-at-point (list (current-local-map)))
    ;; (setq-local corfu-auto nil) Enable/disable auto completion
    (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                corfu-popupinfo-delay nil)
    (corfu-mode 1)))

;; enable corfu for the eval (M-:) minibuffer
(add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)
#+END_SRC

*** Completion with previews
#+begin_src emacs-lisp
  ;; -*- lexical-binding: t -*-
(use-package consult
  :bind (("C-c h" . consult-history)
	 ("C-x b" . consult-buffer)
	 ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
	 ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
	 ("C-x 5 b" . consult-buffer-other-frame))  ;; orig. switch-to-buffer-other-frame
	 :config
	 (use-package embark-consult
	   :hook
	   (embark-collect-mode . consult-preview-at-point-mode)))
#+end_src
** Configure file backups

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . "~/.local/emacs/backup")
			       (,tramp-file-name-regexp nil)))
(setq backup-by-copying-when-linked t)
(setq delete-old-versions t)
(setq kept-new-versions   6)
(setq kept-old-versions   2)
(setq version-control     t)

(setq auto-save-file-name-transforms
      `((".*" "~/.local/emacs/auto-save" t)))
#+END_SRC

** Require confirmation before quitting

#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

** Easier confirmation of destructive actions

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disable suspending frames

#+BEGIN_SRC emacs-lisp
  (put 'suspend-frame 'disabled t)
#+END_SRC

** TODO Simplify operating on S-expr

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package smartparens)
#+END_SRC

or

#+BEGIN_SRC emacs-lisp :tangle no
(use-package paredit
  :hook emacs-lisp-mode)
#+END_SRC

** Optionally log executed commands in a separate window

#+BEGIN_SRC emacs-lisp
  ;; Show command log using "C-c o"
  (use-package command-log-mode)
#+END_SRC

** User-friendly minibuffer

#+BEGIN_SRC emacs-lisp
(use-package vertico
  :init
  (vertico-mode)
  :custom
  (vertico-cycle t)
  :config
  (use-package embark ;; mini-buffer actions
    :bind
    (("C-."    . embark-act     )
     ("<menu>" . embark-act     )
     ("C->"    . embark-become  )
     ("M-."    . embark-dwim    )
     ("C-h B"  . embark-bindings))
    :init
    (setq prefix-help-command #'embark-prefix-help-command))
  (use-package savehist ;; remembers previous commands
    :init
    (savehist-mode)
    :config
    (setq history-length 256))
  (use-package marginalia ;; provides more contextual info
    :init
    (marginalia-mode)))
#+END_SRC

** Colorful parenthesis

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** Better help

The *helpful* package describes various symbols much 
better than the vanilla package.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :commands (helpful-callable helpful-variable helpful-command helpful-key)
  :config
  (setq helpful-switch-buffer-function #'init/try-reuse-helpful-window)
  :bind
  ([remap describe-function] . helpful-callable)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-command ] . helpful-command )
  ([remap describe-symbol  ] . helpful-symbol  )
  ([remap help-for-help    ] . helpful-at-point)
  ([remap describe-key     ] . helpful-key     ))

(defun init/try-reuse-helpful-window (buffer)
  (if (eq major-mode 'helpful-mode)
      (switch-to-buffer buffer)
    (pop-to-buffer buffer)))
#+END_SRC

The reusing of helpful window comes from [[https://d12frosted.io/posts/2019-06-26-emacs-helpful.html][this blog post]].

The *which-key* package show a pop-up window with available 
continuations of the current key stroke chain.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0.3)
    (setq which-key-max-description-length nil)
    (setq which-key-side-window-location 'bottom)
    (setq which-key-sort-order #'which-key-key-order-alpha))

  (which-key-mode) ; for some reason, this doesn't work in :init block of use-pacakge
#+END_SRC

** Navigation

The *ace-window* package provides an easy way
to jump to any visible window directly

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :config
  (global-set-key (kbd "C-x o") 'ace-window))
#+END_SRC

The *avy* package provides an easy way
to jump to any visible character directly

#+BEGIN_SRC emacs-lisp
(use-package avy
  :config
  (setq avy-orders-alist '((avy-goto-char   . avy-order-closest)
			   (avy-goto-char-2 . avy-order-closest)))
  (global-set-key (kbd "C-;") 'avy-goto-char-2)
  (define-key isearch-mode-map (kbd "C-;") 'avy-isearch))
#+END_SRC

Alternatively, holymotion simplifies motions:
#+begin_src emacs-lisp :tangle no
(use-package holymotion
  :straight (holymotion :type git
                        :host github
                        :repo "Overdr0ne/holymotion"
                        :branch "main")
  :config
  ;; define some custom motions, I'm using smartparens here
  (holymotion-make-motion
   holymotion-forward-sexp #'sp-forward-sexp)
  (holymotion-make-motion
   holymotion-backward-sexp #'sp-backward-sexp))
#+end_src

#+RESULTS:

** Replace selected text
#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

** Remember point position in file

#+BEGIN_QUOTE 
  When you visit a file, point goes to the last place
  where it was when you previously visited the same file.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (save-place-mode t)
#+END_SRC

** Remember recently opened files

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :init
    (recentf-mode))
#+END_SRC

** Space separated completions

#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+END_SRC

** English Dictionary at hand

#+BEGIN_SRC emacs-lisp
  (use-package mw-thesaurus
    :bind ("C-h w" . #'mw-thesaurus-lookup-dwim))
#+END_SRC

** Easier keymap
#+begin_src emacs-lisp
(defun +define-keymap (&rest bindings)
  (let ((keymap (make-sparse-keymap)))
    (-each bindings (lambda (binding) (+define-key keymap binding)))
    keymap))

(defun +extend-keymap (parent &rest bindings)
  (when (keymapp parent)
    (let ((keymap (apply #'+define-keymap bindings)))
      (set-keymap-parent keymap parent)
      keymap)))

(defun +define-key (keymap binding)
  (let ((key (+define-key-normalize-key (nth 0 binding)))
	(name (nth 1 binding))
	(command (+define-key-normalize-command (nth 2 binding))))
    (define-key keymap key (cons name command))))

(defun +define-key-normalize-key (key)
  (cond ((vectorp key) key)
	((stringp  key) (kbd key))
	(t (user-error "Unsupported %s key: %s " (type-of key) key))))

(defun +define-key-normalize-command (action)
  (cond ((commandp  action) action)
	((keymapp   action) action)
	((functionp action) `(lambda () (interactive) (,action)))
	((listp     action) `(lambda () (interactive) ,action))
	(_ (user-error "Unsupported  %s command: %s" (type-of action) action))))
#+end_src

** Project mask
#+begin_src emacs-lisp
(define-minor-mode project-mode
  "Rebinds the project-related shortcuts to their default emacs bindings"
  :global t
  :lighter " Project"
  :keymap (+define-keymap
	   '([remap consult-buffer] "buffer" consult-project-buffer)
	   '([remap dired] "dired" project-dired)
	   '([remap find-file] "find-file" project-find-file)))
#+end_src

* Software Development

*** testing
#+begin_src emacs-lisp
  (use-package buttercup)
#+end_src
*** (un)quote all words in region
#+begin_src emacs-lisp
  ;; slightly adapted from https://xenodium.com/emacs-quote-wrap-all-in-region/
  (defun region/toggle-word-quote (beg end)
    ;; Quote all words in the selected region.
    ;; Word - everything separated by whitespaces
  (interactive (list (mark) (point)))
  (unless (region-active-p)
    (user-error "no region to wrap"))
  (let* ((deactivate-mark nil)
         (toggle (lambda (word)
                    (if (string-match-p "^\".*\"$" word)
                        (string-trim word "\"" "\"")
                      (format "\"%s\"" word))))
         (words       (split-string (buffer-substring beg end)))
         (replacement (string-join  (mapcar toggle words))))
    (delete-region beg end)
    (insert replacement)))
#+end_src

** Common Lisp
#+begin_src emacs-lisp
(use-package sly
  :config
  (setq inferior-list-program "/usr/bin/sbcl")
  (setq sly-symbol-completion-mode nil))
#+end_src

*** TODO Reconfigure describe (C-h C-h) in sly mode

** Snippets
#+begin_src emacs-lisp
(use-package yasnippet
  :hook ((prog-mode . yas-minor-mode)))
#+end_src

** golang
#+begin_src emacs-lisp
(shell-command-to-string "go install golang.org/x/tools/gopls@latest")
(setq exec-path (append exec-path '("~/go/bin")))
(use-package go-mode)

(require 'project)

(defun project-find-go-module (dir)
  (when-let ((root (locate-dominating-file dir "go.mod")))
    (cons 'go-module root)))

(cl-defmethod project-root ((project (head go-module)))
  (cdr project))

(add-hook 'project-find-functions #'project-find-go-module)
#+end_src

** LSP
#+begin_src emacs-lisp
(use-package eglot)
#+end_src

* Functions
#+begin_src emacs-lisp
(defun uuid ()
  (string-trim (shell-command-to-string "uuidgen")))
#+end_src

#+begin_src emacs-lisp
(use-package org-ql
  :defer 5)
#+end_src
* Security

** Allow setting symmetric-encryption-only easily
#+BEGIN_SRC emacs-lisp
  (defun gpg/symmetric-encryption-only ()
    (setq epa-file-select-keys "symmetric-only")) ;; any value but t or nil will do
#+END_SRC

** Allow setting automatic encryption recipient

#+BEGIN_SRC emacs-lisp
  (defun gpg/encrypt-to (name)
    (setq-local epa-file-encrypt-to (list name)))
#+END_SRC

This can be later used in =use-package= as ~:hook (mode . (lambda () (gpg/encrypt-to "my-email")))~.

Additionally, by setting ~(setq epa-file-select-keys nil)~ (e.g. globally for mode) we can avoid
the popup for selecting targets from all matching keys. If set to nil, all matches will be used.

* Software
** Clojure
#+begin_src elisp
(use-package clojure-mode
  :config
  (use-package cider
    :hook ((cider-repl-mode cider-mode) . eldoc-mode)))
#+end_src
* Major Modes
** dired-mode

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil ; not to be downloaded
  :commands (dired dired-jump)
  :custom
  (dired-listing-switches (pcase system-type
				 (darwin "-agh")
				 (t      "-agho --group-directories-first")))
  (dired-use-ls-dired (not (eq system-type 'darwin)))
  :config
  (use-package dired-single) ;; reuse dired buffer
  (define-key dired-mode-map [remap dired-find-file] 'dired-single-buffer)
  (define-key dired-mode-map [remap dired-mouse-find-file-other-window] 'dired-single-buffer-mouse)
  (define-key dired-mode-map [remap dired-up-directory] 'dired-single-up-directory)
  (use-package all-the-icons-dired
    :if (display-graphic-p)
    :config
    (setq all-the-icons-dired-monochrome nil)
    :init
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
  (use-package dired-collapse ;; collapse directories with only one child into e.g. foo/bar/baz.txt
    :hook (dired-mode . dired-collapse-mode)))
#+END_SRC


*** TODO hide dotfiles

#+BEGIN_SRC emacs-lisp :tangle no
(use-package dired-hide-dotfiles
  :hook (dired-mode . dired-hide-dotfiles-mode))
#+END_SRC

*** TODO open files externally

#+BEGIN_SRC emacs-lisp :tangle no
(use-package dired-open
  :config
  (setq dired-open-extensions '(("mkv" . "mpv"))))
(set-face-attribute 'default nil :font "Hack" :height 300)

#+END_SRC

** various term modes

*** Disable line highlighting in term modes
#+begin_src emacs-lisp
(init/disable-line-highlight 'term-mode-hook)
(init/disable-line-highlight 'vterm-mode-hook)
(init/disable-line-highlight 'shell-mode-hook)
(init/disable-line-highlight 'eshell-mode-hook)
#+end_src

*** Install v-term

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :commands vterm
    :config
    (setq vterm-max-scrollback 10000))
#+END_SRC 

** +hash
#+begin_src emacs-lisp
(cl-defun +hash-map (list &key key (value #'identity) (test 'eql))
  (let ((table (make-hash-table :test test)))
    (-each list (lambda (it) (puthash (funcall key it) (funcall value it) table)))
    table))

(cl-defun +hash-select (table fn)
  (let ((key (funcall fn table)))
    (gethash key table)))
#+end_src

** +complete
#+begin_src emacs-lisp
(cl-defun +completion-item (&key label (group nil) (annotation nil))
  (let ((candidate (s-join " " (-flatten (list label group annotation))))
	(label     (cl-typecase label
		     (list   (s-join " - " label))
		     (string label)))
	(group     (if group (s-join " - " group) "default")))
    (propertize candidate :label label :group group :annotation annotation)))

(cl-defun +completion-annotation (candidate)
  (let* ((annotation (get-text-property 0 :annotation candidate))
	 (width   (length annotation))
	 (padding (propertize " " 'display `(space :align-to (- right ,width)))))
    (concat padding annotation)))

(cl-defun +complete (table &key prompt (category nil) (annotate #'+completion-annotation))
  (cl-labels ((group (candidate transform)
		     (let ((property (if transform :label :group)))
		       (get-text-property 0 property candidate)))
	      (collection (str pred flag)
			  (pcase flag
			    ('metadata (list 'metadata
					     (cons 'group-function #'group)
					     (cons 'category category)))
			    (`t (all-completions str table pred)))))
    (let ((completion-extra-properties (list :annotation-function annotate)))
      (completing-read prompt #'collection))))
#+end_src

** +org-workspace
#+begin_src emacs-lisp
(defcustom +org-workspace-root "~/workspace" "TODO")
(defcustom +org-workspace-default nil "TODO")

(cl-defun +org-workspace-file (workspace &rest segments)
  (apply #'f-join +org-workspace-root workspace "org" segments))

(defcustom +org-extension-rx (rx line-start (not ".") (one-or-more any) ".org" (optional ".gpg") line-end) "TODO")
(cl-defun +org-workspace-files (workspace &rest directories)
  (f-files (apply #'f-join +org-workspace-root workspace "org" directories)
	   (lambda (it) (string-match +org-extension-rx it))))

(defcustom +org-workspace-current-file-name "current" "TODO")
(cl-defun +org-workspace-current-file (workspace)
  (+org-workspace-file workspace (concat +org-workspace-current-file-name ".org")))

#+end_src

** book

#+begin_src emacs-lisp
(cl-defstruct book
  (isbn         (error "Missing isbn")    :read-only)
  (title        (error "Missing title")   :read-only)
  (subtitle     nil :read-only)
  (authors      (error "Missing authors") :read-only)
  (published-by nil :read-only)
  (published-on nil :read-only))

(cl-defun book (isbn)
  (or (book-load  isbn)
      (book-download isbn)))

(defvar book-catalogue nil "TODO")
(defcustom book-catalogue-directory nil "TODO")

(cl-defun book-catalogue-file ()
  (f-join book-catalogue-directory "catalogue.txt"))
(cl-defun book-cover-file (isbn)
  (f-join book-catalogue-directory (format "cover-%s.jpg" isbn)))

(cl-defun book-catalogue ()
  (or book-catalogue
      (setq book-catalogue (book-load-catalogue))))

(cl-defun book-load (isbn)
  (gethash isbn (book-catalogue)))

(cl-defun book-load-catalogue ()
  (let ((rows (when (f-exists? (book-catalogue-file))
		(--> (f-read (book-catalogue-file))
		     (split-string it "\n" t)
		     (mapcar #'read it)))))
    (+hash-map rows :key #'book-isbn :test #'equal)))

(cl-defun book-download (isbn)
  ;; create directories
  (let ((directory (f-parent (book-catalogue-file))))
    (unless (f-exists? directory)
      (f-mkdir-full-path directory)))
  (message "Downloading metadata for ISBN:%s" isbn)
  (let ((json (book-curl isbn)))
    ;; fetch cover, if available
    (when-let ((cover-json (gethash "cover" json))
	       (cover-uri  (gethash "small" cover-json)))
      (call-process "curl" nil nil nil cover-uri "--output" (book-cover-file isbn)))
    (let ((entry (make-book-from-json isbn json)))
      (f-append (format "%S\n" entry) 'utf-8 (book-catalogue-file))
      (puthash isbn entry (book-catalogue)))))

(cl-defun book-curl (isbn)
  (let ((flags '("--disable" "--compressed" "--silent" "--location"))
	(uri (format "https://openlibrary.org/api/books?bibkeys=%s&jscmd=data&format=json" isbn))) ; isbns can be comma-separated
    (with-current-buffer (generate-new-buffer "*book-curl*")
      (apply #'call-process "curl" nil t nil uri flags)
      (goto-char (point-min))
      (prog1 (gethash isbn (json-parse-buffer))
	(kill-buffer (current-buffer))))))

(cl-defun make-book-from-json (isbn json)
  (make-book :isbn isbn
	     :title    (gethash "title" json)
	     :subtitle (gethash "subtitle" json)
	     :authors    (mapcar (lambda (it) (gethash "name" it)) (gethash "authors" json))
	     :published-by (mapcar (lambda (it) (gethash "name" it)) (gethash "publishers" json))
	     :published-on (gethash "publish_date" json)))
#+end_src

#+begin_src emacs-lisp
(setq book-catalogue-directory "~/workspace/mzarnowski/org/books")
#+end_src
** +org

#+BEGIN_SRC emacs-lisp
(use-package doct)
(defcustom +org-link-query
  '(property "ID")
  "TODO")

;; cannot be cl-defun, lands us at the start of the next line after the drawer opening
(defun +org-drawer-start-regexp (name)
  (rx line-start (* (or " " "	")) ":" (eval name) ":" (*? whitespace) line-end))

(defun +org-drawer-store (name value &key unique)
  (save-excursion
    (outline-back-to-heading)
    (let ((next-heading (save-excursion (outline-next-heading) (point))))
      (if-let ((drawer-start (+org-search-drawer-forward name :until next-heading)))
	  ;; since drawer exists, insert unique value only if not already present
	  (unless (and unique
		       (save-excursion
			 (re-search-forward ":END:" next-heading)
			 (re-search-backward (format "^%s$" value) drawer-start t)))
	    (newline) ;; search puts us at the end of the drawer header (i.e. :foo:)
	    (insert value))
	;; otherwise create a new drawer
	(progn
	  ;; move past the PROPERTIES drawer, if any
	  (re-search-forward org-property-drawer-re next-heading t)
	  (newline) ;; we are at the end of the headline or drawer header (i.e. :foo:)
	  (insert ":" name ":\n" value "\n:END:")
	  ;; let's finish at the same place, the goto-drawer would: end of the drawer header
	  (previous-line))))))

(cl-defun +org-search-drawer-forward (name &key until)
  (let ((pattern (+org-drawer-start-regexp name)))
    (re-search-forward pattern until t)))

(defcustom +org-backlink-drawer-name "DERIVED" "TODO")
(defcustom +org-link-schema "+id" "TODO")

(org-link-set-parameters +org-link-schema :follow #'+org-link-follow)

(cl-defun +org-entry-completing-read (workspace &key prompt)
  (let* ((buffers-files (+org-workspace-files workspace))
	 (entries (org-ql-select buffers-files '(property "ID")
		    :action (lambda () (let ((outline (org-get-outline-path t)))
					 (list (car (last outline))
					       :group  (car (last outline 2))
					       :marker (point-marker)
					       :id     (org-id-get))))))
	 (table (+hash-map entries
			   :key (lambda (it) (apply #'+completion-item it))
			   :test #'equal)))
    (gethash (+complete table :prompt prompt) table)))

(defvar +org-open-entries (make-hash-table :test #'equal))

(cl-defun +org-entry-to-indirect-buffer (marker)
  (with-current-buffer (marker-buffer marker)
    (save-excursion
      (goto-char (marker-position marker))
      (org-tree-to-indirect-buffer)))
  (with-current-buffer org-last-indirect-buffer
    (add-hook 'kill-buffer-hook (lambda () (remhash (org-id-get) +org-open-entries)) nil t)
    (puthash id (current-buffer) +org-open-entries)
    (current-buffer)))

(cl-defun +org-entry-find (workspace)
  (interactive '("mzarnowski"))
  (when-let* ((selected (+org-entry-completing-read workspace :prompt "Entry: "))
	      (id     (plist-get (cdr selected) :id))
	      (marker (plist-get (cdr selected) :marker)))
    (if-let* ((buffer (gethash id +org-open-entries))
	      (_ (buffer-live-p buffer)))
	(pop-to-buffer buffer)
      (pop-to-buffer (+org-entry-to-indirect-buffer marker)))))

(cl-defun +org-link (workspace)
  (interactive '("mzarnowski"))
  (unless (derived-mode-p 'org-mode))
  (if-let* ((selected (+org-entry-completing-read workspace :prompt "Link: "))
	    (name (car selected))
	    (id (plist-get (cdr selected) :id)))
      (insert (org-link-make-string (format "%s:%s:%s" +org-link-schema workspace id) name))))

(cl-defun +org-link-follow (link _)
  (-let* (((workspace id) (s-split ":" link))
	  (buffers-files (+org-workspace-files workspace))
	  ((marker _) (org-ql-select buffers-files `(property "ID" ,id) :action #'point-marker)))
    (pop-to-buffer-same-window (marker-buffer marker))
    (goto-char (marker-position marker))
    (end-of-line)))

#+end_src

** +org-refile

#+begin_src emacs-lisp
(defcustom +org-refile-target-providers '()
  "TODO (name :keywords <list-of-strings>
              :group <e.g. projects - books>
              :properties <list of pairs>)")

(cl-defun +org-refile (workspace)
  (interactive '("mzarnowski"))
  (save-excursion
    (outline-back-to-heading t)
    (while (and (< 1 (funcall outline-level)) (not (org-id-get)))
      (outline-up-heading 1))
    ;; TODO what, if no more headings and still no ID?
    (unless (org-id-get)
      (error "Cannot refile an entry without ID"))
    (when-let* ((file   (+org-workspace-current-file workspace))
		(target (+org-refile-completing-read workspace))
		(marker (+org-refile-target-marker (find-file-noselect file) target)))
      (org-refile nil nil (list heading file nil marker)))))

(cl-defun +org-refile-completing-read (workspace)
  (let ((targets (+org-refile-targets workspace)))
    (unless targets
      (error "No place to refile to"))
    (let* ((table     (+hash-map targets :key #'+org-refile-completion-item :test #'equal))
	   (selection (+complete table :prompt "Target: ")))
      (or (gethash selection table) selection))))

(cl-defun +org-refile-targets (workspace)
  (-flatten-n 1 (mapcar (lambda (f) (funcall f workspace)) +org-refile-target-providers)))

(cl-defun +org-refile-completion-item (target)
  (let ((group      (or (plist-get target :group) '("projects")))
	(annotation (plist-get target :annotation))
	(label (mapcar #'car (plist-get target :path))))
    (+completion-item :label label :group group :annotation annotation)))

(cl-defun +org-refile-target-marker (buffer target)
  (when-let ((path (cl-typecase target
		     (list   (plist-get target :path))
		     (string (when (y-or-n-p (format "Create project %s? " target))
			       `((,target :group "projects")))))))
    (with-current-buffer buffer
      (save-excursion
	(goto-char (point-min))
	(+org-refile-find-or-create path)))))

(cl-defun +org-refile-target-create (buffer name)
  (when (y-or-n-p (format "Create project %s?" name))
    (+org-refile-find)))

(cl-defun +org-refile-find-or-create (path)
  (cl-loop for segment in path
	   for name       = (car segment)
	   for properties = (cdr segment)

	   for level = (if level (1+ level) (or (org-current-level) 1))
	   for marker = (+org-search-heading level name)
	   while marker

	   finally return (or marker (+org-outline-create level path))))

(cl-defun +org-search-heading (level name)
  (cl-loop with position = (point)
	   while (re-search-forward org-complex-heading-regexp nil t)

	   for level-diff = (- (length (match-string 1)) level)
	   for heading    = (match-string 4)
	   for found      = (and (= 0 level-diff) (string= name heading))

	   until (or found (< level-diff 0))

	   finally do     (unless found (goto-char position))
	   finally return (when found (point-marker))))

(cl-defun +org-outline-create (level path)
  (cl-loop with top-level = (when (= 1 level) (car path))
	   initially do (when top-level
			  (+org-insert-heading (car top-level) (cdr top-level)))

	   with segments  = (if top-level (cdr path) (-drop (1- level) path))

	   for segment in segments
	   for name       = (car segment)
	   for properties = (cdr segment)

	   do (+org-insert-subheading name properties)

	   finally do     (when properties (outline-back-to-heading) (end-of-line))
	   finally return (point-marker)))

(cl-defun +org-insert-heading (name properties)
  (org-insert-heading nil t t)
  (insert name)
  (+org-set-properties properties))

(cl-defun +org-insert-subheading (name properties)
  (org-insert-subheading nil)
  (insert name)
  (+org-set-properties properties))

(cl-defun +org-set-properties (properties)
  (cl-loop for key   in      properties  by #'cddr
	   for value in (cdr properties) by #'cddr

	   for key   = (+org-to-string key)
	   for value = (+org-to-string value)
	   do (org-set-property key value)))

(cl-defun +org-to-string (it)
  (s-upcase (cl-typecase it
	      (string  it)
	      (symbol  (string-trim-left (symbol-name it) (rx ":")))
	      (integer (int-to-string it))
	      (t (error "Unsupported type %s" (type-of it))))))
#+end_src

*** +org-refile-book extensions
#+begin_src emacs-lisp
(cl-defun +org-refile-book-target (book)
  (list :path `((,(book-title book) :ISBN ,(book-isbn book)))
	:group '("projects" "books")
	:annotation (string-join (book-authors book) "; ")))

(cl-defun +org-refile-book-targets (workspace)
  (let ((books (book-catalogue))
	(targets '()))
    (maphash (lambda (isbn book)
	       (push (+org-refile-book-target book) targets))
	     (book-catalogue))
    targets))

(add-hook '+org-refile-target-providers #'+org-refile-book-targets)
#+end_src

*** +org-refile-journal extension
#+begin_src emacs-lisp
(cl-defun +org-refile-journal-target (workspace)
  (list (list :path `(("journal") (,(format-time-string "%F"))))))

(add-hook '+org-refile-target-providers #'+org-refile-journal-target)
#+end_src

** +org-capture

#+begin_src emacs-lisp
(cl-defun +org-capture (workspace)
  (interactive '("mzarnowski"))
  (let ((file (+org-workspace-file workspace "inbox" (concat (uuid) ".org"))))
    (with-current-buffer (find-file-noselect file)
      (org-mode)
      (+org-capture-mode)
      (pop-to-buffer (current-buffer)))))

(cl-defun +org-next-captured (workspace)
  (interactive '("mzarnowski"))
  (if-let ((files (+org-workspace-files workspace "inbox")))
      (find-file (car files))
    (message "Inbox is empty")))

(cl-defun +org-capture-refile (workspace)
  (interactive '("mzarnowski"))
  (save-excursion
    (goto-char (point-min))
    (when-let* ((heading (+org-refile-completing-read workspace))
		(file    (+org-workspace-current-file workspace))
		(marker  (+org-refile-target-marker (find-file-noselect file) heading))
		(title   (or (length= (org-ql-select (current-buffer) '(level 1)) 1)
			     (completing-read "Title: " nil)))
		(id      (or (not (null (org-id-get)))
			     (org-id-new))))
      ;; insert title and demote all subtrees
      (when (stringp title)
	;; insert root headline
	(save-excursion
	  (insert "* " title)
	  (newline-and-indent))
	;; demote all other trees
	(save-excursion
	  (while (and (not (eobp))
		      (outline-next-heading))
	    (org-demote))))

      (when (stringp id)
	(org-set-property "ID" id))

      (org-refile nil nil (list heading file nil marker))
      (delete-file (buffer-file-name))
      (kill-buffer))))

(define-minor-mode +org-capture-mode
  "TODO"
  :interactive nil
  :init-value nil
  :global nil
  :lighter " +Cap"
  :keymap (+define-keymap
	   '([remap org-refile] "capture" +org-capture-refile)))
#+end_src

** org-mode

#+begin_src emacs-lisp
(use-package org
  :bind
  ("C-c n n"                  . +org-capture)
  ("C-c n i"                  . +org-next-captured)
  ([remap org-refile]         . +org-refile)
  ([remap org-capture-refile] . +org-capture-refile)
  :config
  (setq epa-file-select-keys nil) ;; don't prompt for encryption recipients if specified by epa-file-encrypt-to
  (setq org-hide-emphasis-markers      t)
  (setq org-startup-indented           t)
  (setq org-pretty-entities            t)
  (setq org-hide-emphasis-markers      t)
  (setq org-startup-with-inline-images t)
  (setq org-fontify-whole-heading-line t)
  (setq org-edit-src-content-indentation 0
	org-src-tab-acts-natively        t
	org-src-fontify-natively         t
	org-confirm-babel-evaluate       nil)

  (setq +org-workspace-default "mzarnowski")

  (setq org-agenda-file-regexp                 +org-extension-rx)
  (setq org-ql-search-directories-files-regexp +org-extension-rx)
  (setq org-ql-completing-read-reverse-paths   nil)

  (setq org-agenda-files   (list (f-join +org-workspace-root "mzarnowski"))
	org-refile-use-outline-path            t
	org-refile-allow-creating-parent-nodes 'confirm
	org-outline-path-complete-in-steps     nil)

  (unbind-key (kbd "C-c [") 'org-mode-map)
  (unbind-key (kbd "C-c ]") 'org-mode-map)
  (unbind-key (kbd "C-c ;") 'org-mode-map)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)))

  (use-package org-superstar ;; nicer bullets
    :config
    (setq org-superstar-special-todo-items t)
    :hook
    (org-mode . org-superstar-mode))

  (use-package org-appear ;; Show hidden emphasis markers
    :hook
    (org-mode . org-appear-mode)))
#+END_SRC

*** org-roam

#+BEGIN_SRC emacs-lisp
;; (defun org-roam-file-path ()
;;   (let* ((uuid (uuid))
;; 	 (prefix (substring uuid 0 2))
;; 	 (suffix (substring uuid 2)))
;;     (concat prefix "/" suffix)))

;; (use-package org-roam
;;   :custom
;;   (org-roam-directory "~/workspace/mzarnowski/org/notes")
;;   (org-roam-dailies-directory "journal/")
;;   (org-node-completions-everywhere t)
;;   :bind
;;   ;; (("C-c n f" . org-roam-node-find    )
;;   ;;  ("C-c n i" . org-roam-node-insert  )
;;   ;;  ("C-c n l" . org-roam-buffer-toggle)
;;   ;;  ;; configure roam-dailies
;;   ;;  ("C-c n d" . org-roam-dailies-map  )
;;   ;;  :map org-roam-dailies-map
;;   ;;  ("Y" . org-roam-dailies-capture-yesterday)
;;   ;;  ("T" . org-roam-dailies-capture-tomorrow ))
;;   :config
;;   (require 'org-roam-dailies)
;;   (setq org-roam-capture-templates
;;         '(("P" "public" plain "%?"
;;            :target     (file+head "%(org-roam-file-path).org"     "#+title: ${title}\n")
;;            :unnarrowed t)
;;           ("p" "private" plain "%?"
;;            :target     (file+head "%(org-roam-file-path).org.gpg" "#+title: ${title}\n")
;;            :unnarrowed t)))
;;   (setq org-roam-dailies-capture-templates
;; 	`(("d" "default" entry "* %?"
;; 	   :target (file+head "%<%Y-%m-%d>.org.gpg" "#+title: %<%Y-%m-%d>\n"))))
;;   (setq org-return-follows-link t)
;;   (org-roam-setup))
#+END_SRC

*** org-babel
#+begin_src emacs-lisp
(defun org-babel-execute:asm (body params)
  "Compiles, links and runs a single asm file"
  (let* ((src (f-join temporary-file-directory "org-babel-asm.s"))
         (obj (f-join temporary-file-directory "org-babel-asm.o"))
         (exe (f-join temporary-file-directory "org-babel-asm.exe")))
    (with-temp-file src (insert body))
    (shell-command (format "as %s -o %s" src obj))
    (shell-command (format "ld %s -o %s" obj exe))
    (shell-command exe)))
#+end_src

* RSS

The layout of the feed .org file is just an outline with property
drawers defined on each header. There are two properties:
- =url=  - uninherited (duh)
- =feed= - inherited

#+begin_src emacs-lisp
(defun elfeed-org-url ()
  (org-entry-get nil "url"))

(defun elfeed-org-feeds ()
  (let* ((raw   (org-entry-get-with-inheritance "feed"))
	 (feeds (split-string raw " ")))
    (mapcar #'make-symbol feeds)))

(defun elfeed-org-assemble ()
  (let* ((url (elfeed-org-url))
	 (feeds (elfeed-org-feeds)))
    (unless (null url)
      (cons url feeds))))

(defun elfeeds-org-load-file (path)
    (with-temp-buffer
      (org-mode)
      (insert-file-contents path)
      (let ((headlines (cddr (org-element-parse-buffer 'headline)))
	    (feeds (org-map-entries #'elfeed-org-assemble)))
	(remove nil feeds))))

(defun elfeed-reload-feeds ()
  (interactive)
  (setq elfeed-feeds (elfeeds-org-load-file "~/.config/emacs/feeds.org.gpg")))
#+end_src

#+begin_src emacs-lisp
(use-package elfeed
  :commands elfeed
  :hook (elfeed-search-mode . elfeed-reload-feeds))
#+end_src

** TODO [[https://lucidmanager.org/productivity/read-rss-feeds-with-emacs-and-elfeed/][guide #1]]
** TODO [[https://github.com/remyhonig/elfeed-org][org-based config]]

* Potentially interesting packages

** TODO epub: [[https://depp.brause.cc/nov.el/][nov]] and [[https://github.com/chenyanming/nov-xwidget][nov-xwidget]]
** TODO pdf: [[https://github.com/vedang/pdf-tools][pdf-tools]]
** TODO modal: [[https://github.com/Kungsgeten/ryo-modal][ryo-modal]]
** TODO [[https://github.com/sheijk/org-menu][org-menu]]
** TODO better buffer-window [[https://www.emacswiki.org/emacs/IbufferMode][Ibuffer]] and [[https://github.com/purcell/ibuffer-vc][Ibuffer-vc]]
**  Multiplexing terminal
*** TODO [[https://github.com/suonlight/multi-vterm][multi vterm]]

* Potentially interesting topics
** emacs
*** TODO [[https://planet.emacslife.com/][emacs-related blog aggregation]]
*** TODO [[https://github.com/doublep/eldev/][Elisp development tool]]
*** TODO [[http://endlessparentheses.com/fill-and-unfill-paragraphs-with-a-single-key.html?source=rss][Fill-paragraph]]
*** TODO [[http://fgiasson.com/blog/index.php/2016/05/30/creating-and-running-unit-tests-directly-in-source-files-with-org-mode/][Unit tests in org-mode]]
*** TODO [[https://pragmaticemacs.wordpress.com/2015/12/17/master-your-inbox-with-mu4e-and-org-mode/][Email in emacs]]
*** TODO [[https://www.reddit.com/r/emacs/comments/67o5fp/resources_for_developing_major_modes/][Major mode development]]
*** TODO [[https://with-emacs.com/posts/tutorials/what-you-need-to-know-about-hooks/][emacs hooks]]
*** TODO [[https://mihaiolteanu.me/emacs-workspace-management.html][tab-bar mode]]
**** TODO Force only one line
**** TODO Setup tab name
#+begin_src emacs-lisp :tangle no
  (setq tab-bar-tab-name-function 'my-func)
#+end_src

**** TODO Show only buffers from given tab

We can either bind C-x b to C-x p b (project-switch-to-buffer).
This will only work for projects, so we still need to

#+begin_src emacs-lisp :tangle no
  (defun init/switch-to-tab-buffer ()
    (interactive)
    (if (project-current)
        (call-interactively #'project-switch-to-buffer)
      (call-interactively #'switch-to-buffer)))
#+end_src

*** TODO [[https://with-emacs.com/posts/tutorials/almost-all-you-need-to-know-about-variables/][emacs variables]]
*** TODO [[https://with-emacs.com/posts/tips/quit-current-context/][quit minibuffer from other window]]
*** TODO [[https://xenodium.com/emacs-edit-after-org-block-completion/][org-mode complete]]
*** TODO [[https://github.com/emacs-citar/citar][citations]]
*** TODO [[https://yannesposito.com/posts/0022-org-agenda-on-your-startup-page/index.html][org-agenda on startup page]]
*** TODO Better config organization: [[https://d12frosted.io/posts/2021-04-09-emacs-d.html][blog]] and [[https://github.com/d12frosted/environment][git repo]]
*** TODO Task management in org-roam:
- [[https://d12frosted.io/posts/2020-06-23-task-management-with-roam-vol1.html][part 1]]
- [[https://d12frosted.io/posts/2020-06-24-task-management-with-roam-vol2.html][part 2]]
- [[https://d12frosted.io/posts/2020-06-25-task-management-with-roam-vol3.html][part 3]]
- [[https://d12frosted.io/posts/2020-07-07-task-management-with-roam-vol4.html][part 4]]
- [[https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html][part 5]]
- [[https://d12frosted.io/posts/2021-01-24-task-management-with-roam-vol6.html][part 6]]
- [[https://d12frosted.io/posts/2021-05-21-task-management-with-roam-vol7.html][part 7]]

*** TODO [[https://blog.jethro.dev/posts/capturing_inbox/][org-mode workflow]]
*** TODO [[https://github.com/ahungry/md4rd][reddit]]
*** Configs
**** TODO https://gitlab.com/dwt1/dotfiles/-/blob/2a687641af1fa4e31e080960e0b6a5f3d21d759d/.emacs.d.gnu/config.org
** Ergonomics
*** TODO [[https://protesilaos.com/codelog/2022-08-17-re-protect-eyes-coding/][On eyes]]
*** TODO [[https://cyberthal-ghost.nfshost.com/alternatives-to-the-desk-how-to-vary-computing-posture-for-extended-endurance/][Posture]]
** Blogs
*** [[http://www.paulgraham.com/rss.html][Paul Graham]]
